<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Event Loop в JS</title>
</head>
<body>
<h1>Памятка по Event Loop в JavaScript</h1>
<p id="message">Смотри консоль</p>
<script>
  /*
  Event Loop + Call Stack + Callback Queue + Web APIs
  1. Call Stack (стек вызовов)
  место, где выполняются функции
  принцип LIFO
  при переполнении стека Maximum call stack size exceeded

  2. Web APIs (браузер или Node.js)
  внешние среды, которые не являются частью JS, но предоставляющие функции:
  setTimeout, fetch, DOM events, Promise и т.д.
  выполняются асинхронно, не блокируют Call Stack

  3. Callback Queue (очередь задач)
  сюда попадают колбэки из Web APIs, когда они готовы
  принцип FIFO

  4. Event Loop (цикл событий)
  надзиратель, который проверяет:
  - пуст ли Call Stack -> если да, то берет первую задачу из Callback Queue

  Event Loop различает 2 вида задач:
  1. Макротаски (macrotasks), очередь задач (Task Queue) - setTimeout, setInterval, I/O
  2. Микротаски (microtasks), очередь микрозадач - Promise.then/catch.finally, queueMicrotask, MutationObserver

  после каждого завершения синхронного кода (или макротаска) event loop сначала выполняет все микротаски, затем переходит к следующему макротаску
  */

  console.log('1'); // 1 - синхронный код
  setTimeout(() => console.log('2'), 0); // 4 - макротаск
  Promise.resolve().then(() => console('3')); // 3 - микротаск
  console.log('4'); // 2 - синхронный код

  /*
  while (true) {
    // бесконечный цикл блокирует call stack навсегда, event loop не может вмешаться
  }

  т.е.
  1. Синхронный код выполняется первым
  2. Микротаски (промисы) выполняются сразу после синхронного кода
  3. Макротаски (setTimeout) выполняются позже, по одному за "тик" event loop
  */
</script>
</body>
</html>