<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Объекты в JS</title>
</head>
<body>
<h1>Памятка по объектам в JavaScript</h1>
<p id="message">Смотри консоль</p>
<script>
  const user = {
    name: 'Анна',
    age: 25,
    city: 'СПб'
  };
  
  //вывод
  console.log(Object.keys(user)); // массив свойств: name, age, city
  console.log(Object.values(user)); // массив значений : 'Анна', 25, 'СПб'
  console.log(Object.entries(user)); // массив пар ключ-значение: ['name', 'Анна'], ['age', 25], ..
  console.log(Object.fromEntries([['name', 'Анна'], ['age', 25], ['city', 'СПб']])); // получить объект из пар ключ-значение

  //например, при использовании фильтрации
  const filtered = Object.fromEntries(
    Object.entries(user).filter(([key, value]) => key !== 'city')
  );
  console.log(filtered);

  console.log(Object.assign({}, user)); // поверхностоное копирование shallow copy, вложенные объекты копируются по ссылке
  const config = Object.freeze({ api: 'https://api.com'}); // заморозка объекта (добавление/удаление/изменение свойств недоступно)
  
  // запечатывает объект (добавлять/удалять нельзя, но изменять свойства можно)
  /*Object.seal(user);
  user.name = 'Ольга';*/

  // настройка свойства
  Object.defineProperty(user, 'id', {
    value: 123,
    writable: false,
    enumerable: false,
    configurable: false
  });

  // получить дескриптор свойства
  console.log(Object.getOwnPropertyDescriptor(user, 'id')); // { value: .., writable: .. }
  console.log(Object.getOwnPropertyNames(user)); // выводит все свойства, включая неперечисляемые (кроме Symbol)

  // получить массив символьных ключей
  const sym = Symbol('id');
  const obj = { [sym]: 100 };
  console.log(Object.getOwnPropertySymbols(obj));

  // тип объекта (более надежный, чем typeof)
  console.log(Object.prototype.toString.call([])); // [object Array]
  console.log(Object.prototype.toString.call(new Date())); // object Date
  console.log(Object.prototype.toString.call(/regex/)); // object RegExp

  //способы создания объекта
  const objectFirst = { name: 'Анна' }; // литерал
  const objectSecond = new Object(); // new
  const objectThird = Object.create(null); // аргумент обязательный - ссылка на прототип, иначе TypeError

  // обращение к свойствам
  console.log(objectFirst.name); // точечная нотация, через точку
  console.log(objectFirst['name']); // допускается пробел в имени свойства (['full name'])

  /* ключи всегда строки или Symbol, а число будет преобразовано к строке
     при обращении к несуществующему свойству с явным присваиванием свойство будет создано
  */
  objectFirst.surname = 'Петрова';
  console.log(objectFirst);

  /* вариант без задания значения не приведет к undefined, undefined нужно задать явно */
  objectFirst.phone = undefined;
  console.log(objectFirst);

  //удаление свойства
  delete objectFirst.phone;
  console.log(objectFirst);

  /* функция = метод объекта */
  let functionSample = {
    sayHi() {
      console.log('Привет из метода!');
    }
  };
  functionSample.sayHi();

  /* this = ссылка на текущий объект */
  let thisSample = {
    name: 'Анна',
    greet() {
      console.log(`Привет, я ${this.name}`);
    }
  };
  thisSample.greet();

  /* for in для перебора свойств */
  for(let key in objectFirst) {
    console.log(key, objectFirst[key]);
  }

  /* объекты передаются по ссылке. изменение копии приведет к изменению оригинала */
  let copyFirst = { ...objectFirst }; // копирование через спред-оператор
  let copySecond = Object.assign({}, objectFirst); // старый способ

  /* глубокое копирование через JSON.parse */
  console.log(JSON.parse(JSON.stringify(objectFirst)));
</script>
</body>
</html>